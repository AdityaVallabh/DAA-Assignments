%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 11 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
\usepackage{graphicx}
\graphicspath{ {images/} }% paper
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{array}
\usepackage{tabu}
\usepackage{siunitx}
\usepackage{booktabs}% for better rules in the table
%\usepackage[ruled]{algorithm2e}

\usepackage[noend]{algpseudocode}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\title{\LARGE 
IDAA432C Assignment-1 (Group: 41)
}

\author{
  Aditya Vallabh\\
  \texttt{IIT2016517}
  \and
  Kiran Velumuri\\
  \texttt{ITM2016009}
  \and
  Neil Syiemlieh\\
  \texttt{IIT2016125}
  \and
  Tauhid Alam\\
  \texttt{BIM2015003}
}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{ \textbf{Question number: 11} }
\textbf{Take a 10 x 10 matrix (n x n in general) filled with random integer numbers. Trace the
longest sorted partition:-\\
a. in each column of the matrix\\
b. Trace the longest sorted child of the matrix.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

The first part of the question states that we have to find the longest sorted partition in each column of the matrix. That is we have to find the longest continuous sequence of elements in each column of the matrix which is either in ascending or descending order. An algorithm of complexity $O(n^2)$ has been developed for this problem.

As for the second part of the problem, we have to find the longest sorted child of the matrix. The child of a matrix can be obtained by starting from any element in the matrix and proceeding in either of the four directions; left, right, up or down, from that element. The longest sorted child implies that the elements in the child are in increasing or decreasing order and this path should be the longest possible path in the matrix.  An algorithm implementing backtracking has been developed for this part whose complexity is non-polynomial.

Using the relevant test cases, we obtain the time complexity of the algorithms for each of best, average and worst cases. Then we plot the time versus $n$ graphs for the above mentioned cases.


\section{ALGORITHM DESIGN}

The matrix for both the parts can be generated by allocating space using the $malloc()$ function and populating it with random values with the help of $srand()$ function.

\subsection{LONGEST SORTED PARTITION IN A COLUMN}

The longest sorted partition in each column can be found by iterating through each cell and keeping track of the current partition's length and the maximum length found so far. Following are the steps: \\ 
\begin{enumerate}
\item Initialize $maxLen$ and $len$ to one then start traversing each column from the $1^{st}$ element (0-indexed)
\item Increment $len$ if the next cell is sorted w.r.t. the current cell
\item If at any point the current length is greater than the maximum length found so far, reassign the max length and store the index of the initial cell
\item If the next cell doesn't satisfy the current trend, reset the current length and continue

Since 'sorted' could either mean ascending or descending, both the cases should be tracked independently. Finally we end up with the length and the starting index of the longest sorted partition in each column.
\end{enumerate}

\begin{algorithm}
\caption{Longest Sorted Partition algorithm}\label{alg:partition}
\begin{algorithmic}
\For {$j\gets 0~to~n$}
	\For {$i\gets 1~to~n$}
        \If {$matrix[i-1][j]\geq matrix[i][j]$}
            \State $len\gets len+1$
        \Else
        	\State $len\gets1$
        \EndIf    
        \If {$len > max$}
            \State $max\gets len$
            \State $start\gets i - len + 1$
        \EndIf
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{LONGEST SORTED PATH IN THE MATRIX}

Finding the longest sorted path in the matrix requires a recursive traversal throughout the 
\\matrix. Basically we need to perform a Depth First Search on the matrix treating it to be a graph. Each cell would be a node and edges would occur between adjacent cells of non-decreasing values. By backtracking, we can find all possible paths in sorted order.

\begin{enumerate}
\item Assume we have a routine called $recursiveFind()$ which returns the length of the longest sorted path from a given cell. 
\item It first marks the current cell as visited
\item We can implement this routine recursively by calling it for the neighbours (left, right, up, down) of the current cell which are not visited yet and are in non-decreasing order. 
\item Unmark the current cell (backtrack)
\item Return the maximum of the path lengths obtained above. 
\end{enumerate}

\begin{algorithm}
\caption{Recursive Algorithm}
\begin{algorithmic}
	\small
    \Procedure{recursiveFind}{$matrix, n, x, y, len$}
      \State $visited[x][y]\gets matrix[x][y]$
      \If {$len+1~=~maxLen$}
      	\State $printMatrix(visited)$
      \EndIf
      \State $l\gets len+1$
      \State $r\gets len+1$
      \State $u\gets len+1$
      \State $d\gets len+1$
      \If {$visited[x][y-1]==-1~AND~matrix[x][y-1]\geq matrix[x][y]]$}
      	\State $l\gets recursiveFind(matrix, n, x, y-1, len+1)$
      \EndIf
      \If {$visited[x][y+1]==-1~AND~matrix[x][y+1]\geq matrix[x][y]]$}
      	\State $r\gets recursiveFind(matrix, n, x, y+1, len+1)$
      \EndIf
      \If {$visited[x-1][y]==-1~AND~matrix[x-1][y]\geq matrix[x][y]]$}
      	\State $u\gets recursiveFind(matrix, n, x+1, y, len+1)$
      \EndIf
      \If {$visited[x+1][y]==-1~AND~matrix[x+1][y]\geq matrix[x][y]]$}
      	\State $d\gets recursiveFind(matrix, n, x, y, len+1)$
      \EndIf
      \State $visited[x][y]\gets -1$
      \State \textbf{return} $MAX(l,r,u,d)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


Now we can use this routine to find all sorted paths.

\begin{enumerate}
\item Call $recursiveFind()$ for each cell in the matrix. This will return the length of the longest non-decreasing child of the matrix assuming path starts at the current cell.
\item Keep track of the maximum length found so far and the indices of their corresponding starting points.
\item Finally call the $recursiveFind()$ routine again for each of these starting points but this time print the visited matrix when the traversing path length reaches the maximum value i.e. when the last cell in the longest path is reached.
\end{enumerate}

\begin{algorithm}
\caption{Driver function}\label{alg:driver}
\begin{algorithmic}
\small
\For {$i\gets 0~to~n$}
	\For {$j\gets 0~to~n$}
        \State $len\gets recursiveFind(matrix, n, i, j, 0)$    
        \State $init[i][j]\gets len$
        \If {$len > max$}
            \State $max\gets len$
            \State $start\gets i - len + 1$
        \EndIf
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\section{ANALYSIS}
\subsection{LONGEST SORTED PARTITION IN A COLUMN}
The proposed algorithm traverses each cell only once while simultaneously searching for ascending and descending sequences. So for a single column of size $n$, the complexity would be $\theta(n)$. As there are $n$ such columns again in an $n*n$ matrix, the same algorithm would be executed $n$ more times giving us the final complexity as $\theta(n^2)$.

On analysing the time taken by every significant computation step in the algorithm and the frequency of the stepsâ€™ occurrences, the following expression is obtained for the time complexity: \\ 
$ Worst Case:$
\[t\ \alpha\ 20n^2-8n+1 \]
$ Best Case:$
\[t\ \alpha\ 15n^2+2n+1\]
Either way, the time complexity is of the order of $n^2$.

\subsection{LONGEST SORTED PATH IN THE MATRIX}
Analysis of the $recursiveFind$ algorithm is quite difficult because the backtracking steps add an exponential component to the complexity. 
\subsubsection{Best Case}
The best case for this algorithm would occur when the max path length is least as it would lead to the least number of recursive calls and reduces the backtracking steps. The least path length cannot be 1 as any two neighbours are always sorted. So 2 is the minimum path length and therefore the matrix should be filled with alternate elements. This would give a complexity of order $\Omega(n^2)$ as each call to $recursiveFind$ would return after calling a maximum of 4 times.
\subsubsection{Worst Case} Each call to the routine produces 4 more calls corresponding to the 4 directions in the worst case and this continues for each cell until are the cells in the matrix are exhausted. This gives a complexity of $O(4^{n^2})$. Moreover this has to repeated for each cell again taking each one as the beginning of the path giving a final complexity of $O(n^2 * 4^{n^2})$. \\ 
\\ In practice the recursiveFind() will mostly only call 1 or 2 more times as only the first cell would have 4 valid neighbours that too if it is not on the boundary of the matrix and after tracing a part of the path, many cells become visited and hence blocked. Therefore $O(n^2*4^{n^2})$ is an over-exaggeration of the worst complexity and the actual order would be of the form $O(n^2*k^{n^2})$ where $1 < k < 2$.

\section{EXPERIMENTAL STUDY} 
Following are the experimental findings after profiling the data and plotting the relevant graphs using $gnuplot$.

\subsection{Graphs}
\begin{enumerate}
\item Fig. 1. gives the best case, worst case and the average case time complexity for the $findPartition$ algorithm.
\item Fig. 2. gives the best case and average case time complexity of the backtracking algorithm vs values of $n$ till 200. 
\item Fig. 3. is the worst case time complexity for part B plotted for $n$ = 1 to 6.
\item Fig. 4. is additional findings for the part B. It gives the longest sorted path length vs $n$ for 200 cases.
\end{enumerate}

\begin{figure}
\includegraphics[scale=0.45]{3}
\caption{Time Complexity for Part A}
\end{figure}

\begin{figure}
\includegraphics[scale=0.65]{1}
\caption{Time Complexity for Part B}
\end{figure}

\begin{figure}
\includegraphics[scale=0.5]{4}
\caption{Worst Case for Part B}
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.65]{2}
\caption{Longest Path Length vs N}
\end{figure}

\subsection{Profiling}

$$Time Complexity$$

\begin{table}[h!]
\fontsize{8}{11}\selectfont
\begin{center}
\begin{tabu} to 0.5\textwidth {|X[c]|X[c]|X[c]|X[c]|X[c]|X[c]|X[c]|X[c]|} 
 \hline
 Size (n) & 50 & 75 & 100 & 125 & 150 & 175 & 200 \\
 \hline\hline
 $t_{max}$ & 49601 & 111901 & 199201 & 311501 & 448801 & 611101 & 790429 \\
 \hline
 $t_{avg}$ & 38216 & 85601 & 151646 & 236631 & 340216 & 462591 & 597819 \\
 \hline
 $t_{min}$ & 37601 & 84526 & 150201 & 234626 & 337801 & 459726 & 594414 \\
 \hline
\end{tabu}
\label{partition_table}
\caption{Part 1 - Longest sorted partition}
\end{center}
\end{table}

\begin{table}[h!]
\fontsize{7.5}{11}\selectfont
\begin{center}
\begin{tabu} to 0.5\textwidth {|X[c]|X[c]|X[c]|X[c]|X[c]|X[c]|X[c]|} 
 \hline
 n & 35 & 70 & 105 & 140 & 175 & 200 \\
 \hline\hline
 $t_{avg}$ & 309086 & 1311148 & 2893500 & 5229024 & 8279143 & 10753165 \\
 \hline
 $t_{min}$ & 225249 & 913612 & 2065024 & 3679487 & 5756999 & 7449203 \\
 \hline
\end{tabu}
\label{path_table}
\caption{Part 2 - Longest child best and average cases}
\end{center}
\end{table}

\begin{table}[h!]
\fontsize{7.5}{11}\selectfont
\begin{center}
\begin{tabu} to 0.5\textwidth {|X[c]|m{1em}|m{1.5em}|m{2em}|X[c]|X[c]|X[c]|}
 \hline
 n & 1 & 2 & 3 & 4 & 5 & 6 \\
 \hline\hline
 $t_{max}$ & 82 & 1892 & 34101 & 1882452 & 154667081 & \num{5.7e10} \\
 \hline
\end{tabu}
\label{path_table_worst}
\caption{Part 2 - Longest child worst case}
\end{center}
\end{table}

\subsection*{LONGEST SORTED PARTITION IN A COLUMN}
It can be observed both from the graph and the table that the best, worst and average cases have almost similar time complexities and the graph resembles

\qquad \qquad \qquad $y = Ax^2 + Bx + C$

\subsection*{LONGEST SORTED PATH IN THE MATRIX}
The average and the best case plots are almost identical whereas the worst case plot escalates very quickly making it hard to plot for larger values of n. This implies due to the randomness in the average case, it is somewhat close to the best case which is a parabola.

Thus we can safely say that our theoretical calculations match with the experimental study.

\section{Discussion}

\subsection{Generation of random numbers}
In order to fill the $n*n$ matrix with random numbers, we have used the  $rand()$, $srand()$ functions and the $<time.h>$ header file.

The $rand()$ function generates a pseudo random number, that is, the same random number is generated every time we compile and run the program. 
So, we used the $srand()$ function to set the seed for the $rand()$ function.

\subsection{Complexity of the longest sorted path}
This problem is likely to belong to the NP class of problems. However the average case is good owing to the random numbers implying the probability to get a matrix close to the best case seems to be relatively greater.

\subsection{Path Length vs N}
This is an interesting observation in the problem. As we increase $n$, the rate of increase in the length of the longest sorted path appears to be decreasing; meaning the larger the matrix, the lesser the chances of getting a longer path.

\subsection{Tracing all possible paths}
In the algorithm all the possible paths are being explored while backtracking. So instead of breaking after finding a possibility we modified the algorithm to trace all paths of the maximum length. This number was plotted alongside $n$ but as such no relation was found.

\section{Conclusion}
In the first module, we have implemented an $\theta(n^2)$ algorithm and for the second module an algorithm using backtracking has been developed whose average case very close to the best case which has a $\Omega(n^2)$ complexity. Graphs have also been plotted and agree with the theoretically calculated complexities.

\end{document}
